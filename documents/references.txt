Avoid changing VAO attachments (vertexAttribPointer, disable/enableVertexAttribArray)

Drawing from static, unchanging VAOs is faster than mutating the same VAO for every draw call. For unchanged VAOs, browsers can cache the fetch limits, whereas when VAOs change, browsers must revalidate and recalculate limits. The overhead for this is relatively low, but re-using VAOs means fewer vertexAttribPointer calls too, so it's worth doing wherever it's easy.

https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices



Uniform Buffer Objects

Uniform Buffer Objects let you specify a bunch of uniforms from a buffer. The advantages are:

    You can manipulate all the uniforms in the buffer outside of WebGL.

    In WebGL1 if you had 16 uniforms that would require 16 calls to gl.uniformXXX, that is relatively slow. In WebGL2 if you use a Uniform Buffer Object you can set the values in a typed array all inside JavaScript which means it's much much faster. When all the values are set you upload them all with 1 call to gl.bufferData or gl.bufferSubData and then tell the program to use that buffer with gl.bindBufferRange so only 2 calls.

    You can have different sets of uniform buffer objects.

    First some terms. A Uniform Block is a collection of uniforms defined in a shader. A Uniform Buffer Object is a buffer that contains the values a Uniform Block will use. You can create as many Uniform Buffer Objects as you want and bind one of them to a particular Uniform Block when you draw.

    For example, you could have 4 uniform blocks defined in a shader:

        A global matrix uniform block that contains matrices that are the same for all draw calls like the projection matrix, view matrix, etc.

        A per model uniform block that contains matrices that are different per model. For example, the world matrix and normal matrix.

        A material uniform block that contains the material settings like diffuse, ambient, specular, etc.

        A lighting uniform block that contains the lighting data like light color, light position, etc.

    Then at runtime you could create one global uniform buffer object, one model uniform buffer object per model, one light uniform buffer object per light, and one uniform buffer object per material.

    To draw any particular item, assuming all the values are already up to date, all you have to do is bind your desired 4 uniform buffer objects:

    https://webgl2fundamentals.org/webgl/lessons/webgl2-whats-new.html


TODO: Ensure GL buffers are correctly destroyed on exception!!
TODO: Create TextureBuffer, MeshBuffer, MaterialBuffer and Shader classes OR add "getVertexArray" "getShaderProgram" to classes. Shader(vertexSource: string, fragmentSource: string)

Add GL binding to Mesh, Texture, Material and Shader classes with FinalizationRegistry to unbind on cleanup. Asset loader can use WeakRef to return cached version if not garbage collected.
